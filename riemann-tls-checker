#!/usr/bin/env ruby
# frozen_string_literal: true

require 'active_support/time_with_zone'
require 'action_view'
require 'action_view/helpers'

require 'openssl'
require 'socket'

class UnableToGetCertificate < RuntimeError
end

class LineOrientedSocket < TCPSocket
  def gets
    line = ''

    line += read(1) until line.end_with?("\r\n")

    line
  end

  def puts(data)
    send("#{data}\r\n", 0)
  end
end

class CertificateChecker
  include ActionView::Helpers::DateHelper

  def initialize(hostname)
    @hostname = hostname
  end

  def to_e
    {
      state: state,
      metric: metric,
      description: description,
      service: "X.509/#{@hostname}",
      subject: certificate&.subject.to_s,
      issuer: certificate&.issuer.to_s,
      serial: certificate&.serial.to_i,
      not_before: certificate&.not_before.to_s,
      not_after: certificate&.not_after.to_s,
    }
  end

  def to_s
    description
  end

  private

  def description
    if !certificate
      "#{@hostname} does not have a valid certificate"
    elsif !match_domain?
      'certificate subject does not match hostname'
    elsif not_valid_yet?
      "certificate will become valid in #{distance_of_time_in_words_to_now(certificate.not_before)}"
    else
      "certificate will expire in #{distance_of_time_in_words_to_now(certificate.not_before)}"
    end
  end

  def state
    if !match_domain? || not_valid_yet? || expired_or_expire_soon?
      'critical'
    elsif expire_soonish?
      'warn'
    else
      'ok'
    end
  end

  def metric
    certificate.not_after - now if certificate
  end

  def now
    @now ||= Time.now
  end

  def not_valid_yet?
    now < certificate.not_before
  end

  def expired_or_expire_soon?
    now + 3600 * 24 * 2 > certificate&.not_after
  end

  def expire_soonish?
    now + 3600 * 24 * 14 > certificate&.not_after
  end

  def match_domain?
    return true if domain == @hostname

    san = certificate.extensions.select { |ext| ext.oid == 'subjectAltName' }.first
    return san.value.split(', ').map { |name| name.sub(/\ADNS:/, '') }.include?(@hostname) if san

    false
  end

  def domain
    certificate.subject.to_a.select { |data| data[0] == 'CN' }.map { |data| data[1] }.first if certificate
  end

  def certificate
    @certificate ||= OpenSSL::X509::Certificate.new(tls_socket.peer_cert)
  rescue Exception => e
    raise UnableToGetCertificate.new(e)
  end

  def tls_socket
    @tls_socket ||= if @hostname.start_with?('smtp.')
                      smtp_socket
                    elsif @hostname.start_with?('imap.')
                      imap_socket
                    else
                      basic_socket
                    end
  end

  def basic_socket
    ssl_socket = OpenSSL::SSL::SSLSocket.new(TCPSocket.new(@hostname, port), ssl_context)
    ssl_socket.hostname = @hostname
    begin
      ssl_socket.connect
    rescue OpenSSL::SSL::SSLError # rubocop:disable Lint/HandleExceptions
      # This may fail for example if a client certificate is required
    end
    ssl_socket
  end

  def imap_socket
    socket = LineOrientedSocket.new(@hostname, port)
    loop do
      line = socket.gets
      break if line.start_with?('* OK ')
    end
    socket.puts('. CAPABILITY')
    loop do
      line = socket.gets
      break if line.start_with?('. OK')
    end
    socket.puts('. STARTTLS')
    loop do
      line = socket.gets
      break if line.start_with?('. OK')
    end

    ssl_socket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
    ssl_socket.connect
    ssl_socket
  end

  def smtp_socket
    socket = LineOrientedSocket.new(@hostname, port)
    loop do
      line = socket.gets
      break if line.start_with?('220 ')
    end
    socket.puts("EHLO #{my_hostname}")
    loop do
      line = socket.gets
      break if line.start_with?('250 ')
    end
    socket.puts('STARTTLS')
    socket.gets

    ssl_socket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
    ssl_socket.connect
    ssl_socket
  end

  def my_hostname
    Socket.gethostbyname(Socket.gethostname).first
  end

  def ssl_context
    ssl_context = OpenSSL::SSL::SSLContext.new
    # We do not care about trust here, only expiration dates.

    #  ____              _ _                                                 _
    # |  _ \  ___  _ __ ( ) |_    ___ ___  _ __  _   _       _ __   __ _ ___| |_ ___
    # | | | |/ _ \| '_ \|/| __|  / __/ _ \| '_ \| | | |_____| '_ \ / _` / __| __/ _ \
    # | |_| | (_) | | | | | |_  | (_| (_) | |_) | |_| |_____| |_) | (_| \__ \ ||  __/
    # |____/ \___/|_| |_|  \__|  \___\___/| .__/ \__, |     | .__/ \__,_|___/\__\___|
    #                                     |_|    |___/      |_|
    #  _   _     _     _
    # | |_| |__ (_)___| |
    # | __| '_ \| / __| |
    # | |_| | | | \__ \_|
    #  \__|_| |_|_|___(_)
    #
    # YOU SHALL  NOT  "COPY-PASTE"  THE FOLLOWING LINE  IN YOUR CODE.  IF YOU
    # UNDESTAND WHY WE DO TAHT,  YOU KNOW WHY YOU DON'T WANT TO DO THIS.   IF
    # YOU DO NOT UNDERSTAND WHAT IT DOES,  REALIZE THAT YOUR PROBLEM VANISHED
    # WHEN YOU PASTE IT AND SHIP IT, FEL FREE TO GET BACK TO ME WHEN YOU WILL
    # DISCOVER THAT YOU HAVE WAY  MORE PROBLEMS  THAN YOU THOUGH.   I WILL BE
    # PLEASED TO  EXCHANGE MONEY WITH ADVICES AND ASSISTANCE  FOR FIXING YOUR
    # PROBLEMS.
    ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
    ssl_context
  end

  def port
    if @hostname.start_with?('smtp.')
      25
    elsif @hostname.start_with?('imap.')
      143
    elsif @hostname.start_with?('puppet.')
      8140
    else
      443
    end
  end
end

ARGV.each do |hostname|
  begin
    cc = CertificateChecker.new(hostname)
    puts cc.to_e
  rescue UnableToGetCertificate
    e = {
      state: 'critical',
      description: 'Cannot fetch certificate',
      service: "X.509/#{hostname}",
    }

    puts e
  end
end
