#!/usr/bin/env ruby
# frozen_string_literal: true

require 'active_support/time_with_zone'
require 'action_view'
require 'action_view/helpers'
require 'net/ldap'

require 'openssl'
require 'resolv'
require 'socket'

class LineOrientedSocket < TCPSocket
  def gets
    line = ''

    line += read(1) until line.end_with?("\r\n")

    line
  end

  def puts(data)
    send("#{data}\r\n", 0)
  end
end

class CertificateCheckerFactory
  def initialize
    @resolver = Resolv::DNS.new
  end

  def certificate_checkers_for(hostname)
    @resolver.getaddresses(hostname).map { |ip| CertificateChecker.new(hostname, ip.to_s) }
  end
end

class CertificateChecker
  include ActionView::Helpers::DateHelper

  def initialize(hostname, address)
    @hostname = hostname
    @address = address
  end

  def to_e
    event = {
      state: state,
      description: description,
      service: "X.509/#{@hostname}/#{@address}",
    }
    if certificate
      event.merge!(
        metric: metric,
        subject: certificate&.subject.to_s,
        issuer: certificate&.issuer.to_s,
        serial: certificate&.serial.to_i,
        not_before: certificate&.not_before.to_s,
        not_after: certificate&.not_after.to_s,
      )
    end

    event
  end

  def to_s
    description
  end

  private

  def description
    if !certificate
      @certificate_failure || "#{@hostname} does not have a valid certificate"
    elsif !match_domain?
      'certificate subject does not match hostname'
    elsif not_valid_yet?
      "certificate will become valid in #{distance_of_time_in_words_to_now(certificate.not_before)}"
    else
      "certificate will expire in #{distance_of_time_in_words_to_now(certificate.not_before)}"
    end
  end

  def state
    if !match_domain? || not_valid_yet? || expired_or_expire_soon?
      'critical'
    elsif expire_soonish?
      'warn'
    else
      'ok'
    end
  end

  def metric
    certificate.not_after - now if certificate
  end

  def now
    @now ||= Time.now
  end

  def not_valid_yet?
    now < certificate.not_before
  end

  def expired_or_expire_soon?
    now + 3600 * 24 * 2 > certificate&.not_after
  end

  def expire_soonish?
    now + 3600 * 24 * 14 > certificate&.not_after
  end

  def match_domain?
    return false unless certificate
    return true if domain == @hostname

    san = certificate.extensions.select { |ext| ext.oid == 'subjectAltName' }.first
    return san.value.split(', ').map { |name| name.sub(/\ADNS:/, '') }.include?(@hostname) if san

    false
  end

  def domain
    certificate.subject.to_a.select { |data| data[0] == 'CN' }.map { |data| data[1] }.first if certificate
  end

  def certificate
    @certificate = OpenSSL::X509::Certificate.new(tls_socket.peer_cert) if @certificate.nil?
    @certificate
  rescue Errno::ECONNREFUSED, Errno::ETIMEDOUT, Net::LDAP::ConnectionRefusedError => e
    @certificate_failure = e.message
    @certificate = false
  end

  def tls_socket
    @tls_socket ||= if @hostname.start_with?('smtp.')
                      smtp_socket
                    elsif @hostname.start_with?('imap.')
                      imap_socket
                    elsif @hostname.start_with?('ldap.')
                      ldap_socket
                    else
                      basic_socket
                    end
  end

  def basic_socket
    ssl_socket = OpenSSL::SSL::SSLSocket.new(TCPSocket.new(@address, port), ssl_context)
    ssl_socket.hostname = @hostname
    begin
      ssl_socket.connect
    rescue OpenSSL::SSL::SSLError # rubocop:disable Lint/HandleExceptions
      # This may fail for example if a client certificate is required
    end
    ssl_socket
  end

  def imap_socket
    socket = LineOrientedSocket.new(@address, port)
    loop do
      line = socket.gets
      break if line.start_with?('* OK ')
    end
    socket.puts('. CAPABILITY')
    loop do
      line = socket.gets
      break if line.start_with?('. OK')
    end
    socket.puts('. STARTTLS')
    loop do
      line = socket.gets
      break if line.start_with?('. OK')
    end

    ssl_socket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
    ssl_socket.connect
    ssl_socket
  end

  def ldap_socket
    ldap = Net::LDAP.new(host: @address, port: port, encryption: { method: :start_tls, tls_options: tls_options })

    ldap.open do |conn|
      return conn.instance_variable_get(:@open_connection).instance_variable_get(:@conn)
    end
  end

  def smtp_socket
    socket = LineOrientedSocket.new(@address, port)
    loop do
      line = socket.gets
      break if line.start_with?('220 ')
    end
    socket.puts("EHLO #{my_hostname}")
    loop do
      line = socket.gets
      break if line.start_with?('250 ')
    end
    socket.puts('STARTTLS')
    socket.gets

    ssl_socket = OpenSSL::SSL::SSLSocket.new(socket, ssl_context)
    ssl_socket.connect
    ssl_socket
  end

  def my_hostname
    Socket.gethostbyname(Socket.gethostname).first
  end

  def ssl_context
    ssl_context = OpenSSL::SSL::SSLContext.new
    # We do not care about trust here, only expiration dates.

    #  ____              _ _                                                 _
    # |  _ \  ___  _ __ ( ) |_    ___ ___  _ __  _   _       _ __   __ _ ___| |_ ___
    # | | | |/ _ \| '_ \|/| __|  / __/ _ \| '_ \| | | |_____| '_ \ / _` / __| __/ _ \
    # | |_| | (_) | | | | | |_  | (_| (_) | |_) | |_| |_____| |_) | (_| \__ \ ||  __/
    # |____/ \___/|_| |_|  \__|  \___\___/| .__/ \__, |     | .__/ \__,_|___/\__\___|
    #                                     |_|    |___/      |_|
    #  _   _     _     _
    # | |_| |__ (_)___| |
    # | __| '_ \| / __| |
    # | |_| | | | \__ \_|
    #  \__|_| |_|_|___(_)
    #
    # YOU SHALL  NOT  "COPY-PASTE"  THE FOLLOWING LINE  IN YOUR CODE.  IF YOU
    # UNDESTAND WHY WE DO TAHT,  YOU KNOW WHY YOU DON'T WANT TO DO THIS.   IF
    # YOU DO NOT UNDERSTAND WHAT IT DOES,  REALIZE THAT YOUR PROBLEM VANISHED
    # WHEN YOU PASTE IT AND SHIP IT, FEL FREE TO GET BACK TO ME WHEN YOU WILL
    # DISCOVER THAT YOU HAVE WAY  MORE PROBLEMS  THAN YOU THOUGH.   I WILL BE
    # PLEASED TO  EXCHANGE MONEY WITH ADVICES AND ASSISTANCE  FOR FIXING YOUR
    # PROBLEMS.
    ssl_context.set_params(tls_options)
    ssl_context
  end

  def tls_options
    {
      verify_mode: OpenSSL::SSL::VERIFY_NONE,
    }
  end

  def port
    if @hostname.start_with?('smtp.')
      25
    elsif @hostname.start_with?('imap.')
      143
    elsif @hostname.start_with?('ldap.')
      389
    elsif @hostname.start_with?('puppet.')
      8140
    else
      443
    end
  end
end

factory = CertificateCheckerFactory.new

ARGV.each do |hostname|
  factory.certificate_checkers_for(hostname).each do |checker|
    puts checker.to_e
  end
end
